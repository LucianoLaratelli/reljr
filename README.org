#+TITLE: reljr
#+AUTHOR: Elijah Malaby
#+AUTHOR: Luciano Laratelli
#+LATEX_HEADER: \usepackage[margin=.75in]{geometry}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{unicode-math}
#+LATEX_HEADER: \setmainfont{FreeSerif}
#+LATEX_HEADER: \setlength\parindent{0pt}
#+OPTIONS: date:nil toc:nil

* Introduction
=reljr= is a relational algebra evaluator written in the [[https://clojure.org/][Clojure]] programming
language to satisfy the requirements for Project Four in the Fall 2020 session
of the Advanced Databases course offered at USF, under the instruction of [[https://www.csee.usf.edu/~tuy/][Dr.
Tu]].
* Getting =reljr=
After cloning the =reljr= repository, it can be started with =clojure -m
reljr.repl= from the top-level =reljr= directory. Alternatively, a jar can be
constructed:
#+begin_src shell
clj -Spom
clj -Xuberjar
#+end_src
Afterwards, the jar can be run with =java -jar target/uberjar/reljr.jar=.
=reljr= was developed and tested under Clojure version 1.10.0 and version
1.8.0_ 265 of OpenJDK.
* Using =reljr=
** Reading tables
- =reljr= expects input tables stored as csv files, with a header row. The headers can be written in one of two ways:
  + =<header>=, i.e. just a string
  + =<header>:<type>=, a string, then a colon, then (optionally) one of the
    following data types. If a data type is not provided, =reljr= treats the
    items in that column as strings.
    - =number= (floats)
    - =string=
- Use =read <filename>= to read a table in the directory from which you launched
  =reljr=.
  + If the filename is =bar.csv=, reljr will store the table in memory as =bar=.
  + If reljr already knows about a table with this name, it will be overwritten.
- Use =read <filename> as <tablename>= to specify the name =reljr= associates
  with a table. If the specified name already exists in memory, the table will
  be overwritten.
- Table names are /case-sensitive/, so reading =bar.csv= and =Bar.csv= will
  result in two separate tables.
- Using =store <query> as <name>= will store the table that results from a query
  (see [[Performing queries][below]]) with the given name. As always, if the name exists, the table will
  be overwritten
- =reljr= assumes that every column in the table shares the same qualifier
  (i.e., columns =S.n= and =R.n= can't be read in from the same file.)
** Managing in-memory tables
- You can perform a persistent rename of a table (as opposed to the temporary
  renaming that occurs during the relational algebra "rename relation"
  operation) with =rename <tablename> to <name>=.
- You can unload an in-memory table with =unload <tablename>=.
- If you make changes to a table and want to update it within =reljr=, use
  =read= again.
- The =list= command will output the names of all currently loaded tables, along
  with each tables' column names.
** Performing queries
A query can be run on its own after a table load or as part of e.g. the =store=
command above. If a table does not exist, it is treated as if it were an empty
table. The result of such a query is an empty table.

=reljr= supports the following types of relational algebra queries, with the
tokens =reljr= recognizes for the operation listed after each:
- Projection (π, =pi=, =project=)
- Selection (σ, =sigma=, =select=), with the following boolean operations:
  + Not (¬, =not=)
  + And (∧, =&&=, =and=)
  + Or (∨, =||=, =or=)
  + Equality (=)
  + Inequality (≠, =!==)
  + Greater than (>)
  + Greater than or equal to (≥, =>==)
  + Less than (<)
  + Less than or equal to ( ≤, =<==)
- Renaming of a column or relation (ρ, =rho=, =rename=)
- Order by (τ, =tau=, =order by=), followed by a token to indicate the order of the column:
  + =ASC=, =asc=, =DESC=, =desc=
- Group by (γ, =gamma=, =group by=), with support for these aggregates:
  + =count(*)=
  + =count(<colname>)=
  + =min(<colname>)=
  + =max(<colname>)=
  + =sum(<colname>)=
  + =avg(<colname>)=
- Cross product (×, =*=, =cross join=)
- Inner Join(⋈, ⨝, =join=, =inner join=), with support for the same boolean
  operations as Selection
- Natural Join(⋈, ⨝, =natural join=)
- The set operations:
  + Division (÷, =/=)
  + Intersection (∩, =intersect=)
  + Union (∪, =union=)
  + Subtraction (=-=, =\\=, =except=)
  
** Writing tables
- To write a table out to a file, use =write <tablename>=. This will create a
  file =<tablename>.csv= in the same directory as =reljr=.
- =write <tablename> as <name>= will write out a file to =<name>=, where name
  can be a csv file or an extensionless file. =reljr= doesn't support any other
  file extensions.
- =write= will overwrite any files with the same name.
- If a table has two columns with the same name but which are qualified by different tables (e.g. =R.n= and =S.n=) the =write= command will write a csv with duplicate column headers. 
** Quitting =reljr=
Use =quit=.
* Implementation Details
** Parser
The grammar for the reljr parser and CLI commands is written in Extended
Backus-Naur Form (EBNF). The grammar is entirely contained within the resource
file [[file:resources/RAParser.bnf][RAParser.bnf]]. The grammar and operator precedence order for =QueryCommand=
and all its child nonterminals were developed using the [[https://dbis-uibk.github.io/relax/help][railroad diagrams ]]in the
RelaX wiki as a reference. The grammar and operator precedence for the CLI
commands are unique to =reljr=. We used the third-party [[https://github.com/engelberg/instaparse][Instaparse]] parser
generator library to construct a parser from the EBNF. Instaparse's detailed
error reporting makes it possible for =reljr= to provide much better information
about syntactic errors in user queries compared to those offered by RelaX.
*** CLI Operation Precedence
In decreasing order of precedence:
1. Reading a table from a file
2. Storing a query to a table in memory
3. Renaming an in-memory table
4. Deleting an in-memory table
5. Writing a table to a file
6. Listing all in-memory tables
7. Quitting =reljr=
8. A relational algebra expression (=RAExpression=)
*** RAExpression Precedence
These precedences are the same as those used by [[https://dbis-uibk.github.io/relax/help#relalg-operator-precedence][RelaX]]. In decreasing order of
precedence:
 1. Projection, Selection, Rename Columns, Rename Relation, Group, Order By
 2. Cross Product, Inner Join, Natural Join, Division, a relation name, an
    RAExpression within parentheses
 3. Intersection
 4. Union, Subtraction
** REPL
** Evaluator
The source file [[file:src/reljr/interpreter.clj][interpeter.clj]] deals with the evaluation of relational algebra
expressions and related computations.
*** Evaluation of 

* Future Work
