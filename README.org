#+TITLE: reljr
#+AUTHOR: Elijah Malaby
#+AUTHOR: Luciano Laratelli
#+LATEX_HEADER: \usepackage[margin=.75in]{geometry}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{unicode-math}
#+LATEX_HEADER: \setmainfont{FreeSerif}
#+LATEX_HEADER: \setlength\parindent{0pt}
#+OPTIONS: date:nil toc:nil

* Introduction
=reljr= is a relational algebra evaluator written in the [[https://clojure.org/][Clojure]] programming
language to satisfy the requirements for Project Four in the Fall 2020 session
of the Advanced Databases course offered at USF, under the instruction of [[https://www.csee.usf.edu/~tuy/][Dr.
Tu]].
* Getting =reljr=
After cloning the =reljr= repository, it can be started with =clojure -m
reljr.repl= from the top-level =reljr= directory. Alternatively, a jar can be
constructed:
#+begin_src shell
clj -Spom
clj -Xuberjar
#+end_src
Afterwards, the jar can be run with =java -jar target/uberjar/reljr.jar=.
=reljr= was developed and tested under Clojure version 1.10.0 and version
1.8.0_ 265 of OpenJDK.
* Using =reljr=
** Reading tables
- =reljr= expects input tables stored as csv files, with a header row. The headers can be written in one of two ways:
  + =<header>=, i.e. just a string
  + =<header>:<type>=, a string, then a colon, then (optionally) one of the
    following data types. If a data type is not provided, =reljr= treats the
    items in that column as strings.
    - =number= (floats)
    - =string=
- Use =read <filename>= to read a table in the directory from which you launched
  =reljr=.
  + If the filename is =bar.csv=, reljr will store the table in memory as =bar=.
  + If reljr already knows about a table with this name, it will be overwritten.
- Use =read <filename> as <tablename>= to specify the name =reljr= associates
  with a table. If the specified name already exists in memory, the table will
  be overwritten.
- Table names are /case-sensitive/, so reading =bar.csv= and =Bar.csv= will
  result in two separate tables.
- Using =store <query> as <name>= will store the table that results from a query
  (see [[Performing queries][below]]) with the given name. As always, if the name exists, the table will
  be overwritten
- =reljr= assumes that every column in the table shares the same qualifier
  (i.e., columns =S.n= and =R.n= can't be read in from the same file.)
** Managing in-memory tables
- You can perform a persistent rename of a table (as opposed to the temporary
  renaming that occurs during the relational algebra "rename relation"
  operation) with =rename <tablename> to <name>=.
- You can unload an in-memory table with =unload <tablename>=.
- If you make changes to a table and want to update it within =reljr=, use
  =read= again.
- The =list= command will output the names of all currently loaded tables, along
  with each tables' column names.
** Performing queries
A query can be run on its own after a table load or as part of e.g. the =store=
command above. If a table does not exist, it is treated as if it were an empty
table. The result of such a query is an empty table.

=reljr= supports the following types of relational algebra queries, with the
tokens =reljr= recognizes for the operation listed after each:
- Projection (π, =pi=, =project=)
- Selection (σ, =sigma=, =select=), with the following boolean operations:
  + Not (¬, =not=)
  + And (∧, =&&=, =and=)
  + Or (∨, =||=, =or=)
  + Equality (=)
  + Inequality (≠, =!==)
  + Greater than (>)
  + Greater than or equal to (≥, =>==)
  + Less than (<)
  + Less than or equal to ( ≤, =<==)
- Renaming of a column or relation (ρ, =rho=, =rename=)
- Order by (τ, =tau=, =order by=), followed by a token to indicate the order of the column:
  + =ASC=, =asc=, =DESC=, =desc=
- Group by (γ, =gamma=, =group by=), with support for these aggregates:
  + =count(*)=
  + =count(<colname>)=
  + =min(<colname>)=
  + =max(<colname>)=
  + =sum(<colname>)=
  + =avg(<colname>)=
- Cross product (×, =*=, =cross join=)
- Inner Join(⋈, ⨝, =join=, =inner join=), with support for the same boolean
  operations as Selection
- Natural Join(⋈, ⨝, =natural join=)
- The set operations:
  + Division (÷, =/=)
  + Intersection (∩, =intersect=)
  + Union (∪, =union=)
  + Subtraction (=-=, =\\=, =except=)
  
** Writing tables
- To write a table out to a file, use =write <tablename>=. This will create a
  file =<tablename>.csv= in the same directory as =reljr=.
- =write <tablename> as <name>= will write out a file to =<name>=, where name
  can be a csv file or an extensionless file. =reljr= doesn't support any other
  file extensions.
- =write= will overwrite any files with the same name.
- If a table has two columns with the same name but which are qualified by different tables (e.g. =R.n= and =S.n=) the =write= command will write a csv with duplicate column headers. 
** Quitting =reljr=
Use =quit=.
* Implementation Details
** Parser
The grammar for the reljr parser and CLI commands is written in Extended
Backus-Naur Form (EBNF). The grammar is entirely contained within the resource
file [[file:resources/RAParser.bnf][RAParser.bnf]]. The grammar and operator precedence order for =QueryCommand=
and all its child nonterminals were developed using the [[https://dbis-uibk.github.io/relax/help][railroad diagrams ]]in the
RelaX wiki as a reference. The grammar and operator precedence for the CLI
commands are unique to =reljr=. We used the third-party [[https://github.com/engelberg/instaparse][Instaparse]] parser
generator library to construct a parser from the EBNF. Instaparse's detailed
error reporting makes it possible for =reljr= to provide much better information
about syntactic errors in user queries compared to those offered by RelaX.
*** CLI Operation Precedence
In decreasing order of precedence:
1. Reading a table from a file
2. Storing a query to a table in memory
3. Renaming an in-memory table
4. Deleting an in-memory table
5. Writing a table to a file
6. Listing all in-memory tables
7. Quitting =reljr=
8. A relational algebra expression (=RAExpression=)
*** RAExpression Precedence
These precedences are the same as those used by [[https://dbis-uibk.github.io/relax/help#relalg-operator-precedence][RelaX]]. In decreasing order of
precedence:
 1. Projection, Selection, Rename Columns, Rename Relation, Group, Order By
 2. Cross Product, Inner Join, Natural Join, Division, a relation name, an
    RAExpression within parentheses
 3. Intersection
 4. Union, Subtraction
** REPL
** Interpreter
The source file [[file:src/reljr/interpreter.clj][interpeter.clj]] deals with the evaluation of relational algebra
expressions and related computations. However, the functions in this file
(notably =evaluate=) depend on the table abstraction specified in [[file:src/reljr/table.clj][table.clj]].
Because of this, it is necessary to discuss the implementation of the functions
that constitute the table abstraction before discussing the implementation of
the interpreter itself.
*** The Table Abstraction
=reljr= stores tables internally as sets of maps. This is a convenient
representation: sets trivially guarantee uniqueness of tuples and maps keep
column information close to table data. As an example, consider the table [[example_table][below]].
The Clojure code below the table shows the same table as a Clojure data
structure (assuming the table was read from the file =foo.csv=.)
#+NAME:example_table
#+caption: Table for the relation =foo=
| R.x | S.x | R.y |
|-----+-----+-----|
|   5 | 6.3 |   6 |
|   3 | 9.4 |   2 |

#+NAME: clojure_table_foo
#+begin_src clojure
{"foo"
   #{{:R/x 5 :S/x 6.3 :R/y 6}
     {:R/x 3 :S/x 9.4 :R/y 2}}}
#+end_src
**** Project

The =project= function expects to receive two arguments, =table= and =keys=. For the query =pi x,y foo= and the same data structure as [[clojure_table_foo][above]], the arguments are as follows:
#+begin_src clojure
  table = #{{:R/x 5 :S/x 6.3 :R/y 6} {:R/x 3 :S/x 9.4 :R/y 2}}
  keys = (:R/x :R/y)
#+end_src
The =project= function takes advantage of that fact that Clojure keys (e.g.
=:R/x=) can be used as functions to get the value from a map that is associated
with that key (as in =(:R/x {:R/x 2})=, which returns =2=.) =val-funcs= is then
a function that applies each of the keys to a row of the table. =map= performs
the actual iteration over table rows. The return value of this function is of
the same form as the input (a set of maps) but with only the requested columns:
#+begin_src clojure
#{#:R{:x 3, :y 2} #:R{:x 5, :y 6}}
#+end_src
**** Select
**** Rename
**** Rename-Column
**** Order-Records-By
**** Group-Records-By
**** Cross-Product
**** Inner-Join
**** Natural-Join
*** Evaluation of Relational Algebra Expressions

* Future Work
